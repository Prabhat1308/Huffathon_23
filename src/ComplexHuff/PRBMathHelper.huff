#include './Constants.huff
#include './Helper.Huff'

#define macro GATE1() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x100000000000000000000000000000000 // [0x100000000000000000000000000000000,xn,result,xn,x]
    gt // [0x100000000000000000000000000000000>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    64 shl // [result<<64,xn,x]
    swap1 // [xn,result<<64,x]
    128 shr // [xn >> 128,result<<64,x]
    swap1 // [result<<64,xn >> 128]
} 

#define macro GATE2() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x10000000000000000 // [0x10000000000000000,xn,result,xn,x]
    gt // [0x10000000000000000>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    32 shl // [result<<32,xn,x]
    swap1 // [xn,result<<32,x]
    64 shr // [xn >> 64,result<<32,x]
    swap1 // [result<<32,xn>>64,x]
} 

#define macro GATE3() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x100000000 // [0x100000000,xn,result,xn,x]
    gt // [0x100000000>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    16 shl // [result<<16,xn,x]
    swap1 // [xn,result<<16,x]
    32 shr // [xn >> 32,result<<16,x]
    swap1 // [result<<16,xn >> 32,x]
} 

#define macro GATE4() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x10000 // [0x10000,xn,result,xn,x]
    gt // [0x10000>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    8 shl // [result<<8,xn,x]
    swap1 // [xn,result<<8,x]
    16 shr // [xn >> 16,result<<8,x]
    swap1 // [result<<16,xn >> 8]
} 

#define macro GATE5() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x100 // [0x100,xn,result,xn,x]
    gt // [0x100>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    4 shl // [result<<4,xn,x]
    swap1 // [xn,result<<4,x]
    8 shr // [xn >> 8,result<<4,x]
    swap1 // [result<<4,xn >>8]
} 
#define macro GATE6() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x10 // [0x10,xn,result,xn,x]
    gt // [0x10>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    2 shl // [result<<2,xn,x]
    swap1 // [xn,result<<2,x]
    4 shr // [xn >> 4,result<<2,x]
    swap1 // [result<<2,xn >>4]
} 

#define macro GATE7() = takes(0) returns(0) {
    //Input Stack [result,xn,x] 
    dup2 // [xn,result,xn,x] 
    0x4 // [0x4,xn,result,xn,x]
    gt // [0x4>xn,result,xn,x]
    iszero
    satisfied
    jumpi 

    satisfied:
    1 shl // [result<<1,xn,x]
} 

#define macro PUT_SIGN() = takes(0) returns(0){
  //Input stack [x,x]
    [X3] // [X3,x,x]
    gt // [X3>x,x]
    conditional_jumpi
    jumpi
    0x01 //[1,x]

    conditional_jumpi: // [x]
    [X3] // [1e18,x]
    dup1 // [1e18,1e18,x]
    mul // [1e18*1e18,x]
    sdiv // [1e18*1e18/x]
    PUT_NEG1() // [-1,x]
}

#define macro MOST_SIGNIFICANT_BIT() = takes(0) returns(0) {
    // Input Stack => [0,x]
    PASS1()
    PASS2()
    PASS3()
    PASS4()
    PASS5()
    PASS6()
    PASS7()
    PASS8()

}

#define macro PASS1() = takes(0) returns(0){
  //Input Stack => [msb,x]
  128 // [128,msb,x]
  2   // [2,128,msb,x]
  exp // [2**128,msb,x]
  dup3 // [x,2**128,msb,x]
  slt // [x<2**128,msb,x]
  iszero // [x>=2**128,msb,x]
  condition_met1
  jumpi

  condition_met1: // [msb,x]
  128 // [128,msb,x]
  add // [msb+128,x]
  swap1 // [x,msb+128]
  128 // [128,x,msb+128]
  shr // [x>>128,msb]
  swap1 // [msb,x>>128]

} 

#define macro PASS2() = takes(0) returns(0){
     //Input Stack => [msb,x]
  64 // [64,msb,x]
  2   // [2,64,msb,x]
  exp // [2**64,msb,x]
  dup3 // [x,2**64,msb,x]
  slt // [x<2**64,msb,x]
  iszero // [x>=2**64,msb,x]
  condition_met2
  jumpi

  condition_met2: // [msb,x]
  64 // [64,msb,x]
  add // [msb+64,x]
  swap1 // [x,msb+64]
  64 // [64,x,msb+64]
  shr // [x>>64,msb]
  swap1 // [msb,x>>64]
} 

#define macro PASS3() = takes(0) returns(0){
   //Input Stack => [msb,x]
  32 // [32,msb,x]
  2   // [2,32,msb,x]
  exp // [2**32,msb,x]
  dup3 // [x,2**32,msb,x]
  slt // [x<2**32,msb,x]
  iszero // [x>=2**32,msb,x]
  condition_met3
  jumpi

  condition_met3: // [msb,x]
  32 // [32,msb,x]
  add // [msb+32,x]
  swap1 // [x,msb+32]
  32 // [32,x,msb+32]
  shr // [x>>32,msb]
  swap1 // [msb,x>>32]  
}

#define macro PASS4() = takes(0) returns(0){
   //Input Stack => [msb,x]
  16 // [16,msb,x]
  2   // [2,16,msb,x]
  exp // [2**16,msb,x]
  dup3 // [x,2**16,msb,x]
  slt // [x<2**16,msb,x]
  iszero // [x>=2**16,msb,x]
  condition_met4
  jumpi

  condition_met4: // [msb,x]
  16 // [16,msb,x]
  add // [msb+16,x]
  swap1 // [x,msb+16]
  16 // [16,x,msb+16]
  shr // [x>>16,msb]
  swap1 // [msb,x>>16]  
}

#define macro PASS5() = takes(0) returns(0){
   //Input Stack => [msb,x]
  8 // [8,msb,x]
  2   // [2,8,msb,x]
  exp // [2**8,msb,x]
  dup3 // [x,2**8,msb,x]
  slt // [x<2**8,msb,x]
  iszero // [x>=2**8,msb,x]
  condition_met5
  jumpi

  condition_met5: // [msb,x]
  8 // [8,msb,x]
  add // [msb+8,x]
  swap1 // [x,msb+8]
  8 // [8,x,msb+8]
  shr // [x>>8,msb]
  swap1 // [msb,x>>8]  
}

#define macro PASS6() = takes(0) returns(0){
   //Input Stack => [msb,x]
  4 // [4,msb,x]
  2   // [2,4,msb,x]
  exp // [2**4,msb,x]
  dup3 // [x,2**4,msb,x]
  slt // [x<2**4,msb,x]
  iszero // [x>=2**4,msb,x]
  condition_met6
  jumpi

  condition_met6: // [msb,x]
  4 // [4,msb,x]
  add // [msb+4,x]
  swap1 // [x,msb+4]
  4 // [4,x,msb+4]
  shr // [x>>4,msb]
  swap1 // [msb,x>>4]  
}

#define macro PASS7() = takes(0) returns(0){
    //Input Stack => [msb,x]
  2 // [2,msb,x]
  2   // [2,2,msb,x]
  exp // [2**2,msb,x]
  dup3 // [x,2**2,msb,x]
  slt // [x<2**2,msb,x]
  iszero // [x>=2**2,msb,x]
  condition_met7
  jumpi

  condition_met7: // [msb,x]
  2 // [2,msb,x]
  add // [msb+2,x]
  swap1 // [x,msb+2]
  2 // [2,x,msb+2]
  shr // [x>>2,msb]
  swap1 // [msb,x>>2] 
}

#define macro PASS8() = takes(0) returns(0){
   //Input Stack => [msb,x]
  1 // [1,msb,x]
  2   // [2,1,msb,x]
  exp // [2**1,msb,x]
  dup3 // [x,2**1,msb,x]
  slt // [x<2**1,msb,x]
  iszero // [x>=2**1,msb,x]
  condition_met8
  jumpi

  condition_met8: // [msb,x]
  1 // [1,msb,x]
  add // [msb+1,x]
  swap1 // [x,msb+1]
  pop // [msb+1]
} 

#define macro HELPIT() = takes(0) returns(0){
  // Input Stack => [y,delta,res,sign]
  dup1 // [y,y,delta,res,sign]
  [X3] // [1e18,y,y,delta,res,sign]
  0x02 // [2,1e18,y,y,delta,res,sign]
  mul // [2*1e18,y,y,delta,res,sign]
  sgt // [2*1e18>y,y,delta,res,sign]
  iszero // [2*1e18<=y ? ,y,delta,res,sign]
  condition_ok
  jumpi

  condition_ok: // [y,delta,res,sign]
  0x01 // [1,y,delta,res,sign]
  shr // [y>>1,delta,res,sign]
  swap2 // [res,delta,y>>1,sign]
  dup2 // [delta,res,delta,y>>1,sign]
  add // [res+delta,delta,y>>1,sign]
  swap2 // [y>>1,delta,res+delta,sign]
}