#include './Helper.huff'
#include './Constants.huff'

/// @notice addition
// a + b

#define macro ADD_Z() = takes(4) returns(2) {
    //INPUT STACK => [RE(a),RE(b),IM(a),IM(b)]

    add // [Re(A)+Re(B),Im(A),Im(B)]
    swap2 // [Im(B),Im(A),Re(A)+Re(B)]
    add // [Im(B)+Im(A),Re(A)+Re(B)]
    swap1 // [Re(A)+Re(B),Im(B)+Im(A)]

}

/// @notice subtraction 
// a - b

#define macro SUB_Z() = takes(4) returns(2) {
    //INPUT STACK => [RE(a),RE(b),IM(a),IM(b)]
    sub // [Re(A)-Re(B),Im(A),Im(B)]
    swap2 // [Im(B),Im(A),Re(A)-Re(B)]
    swap1 // [Im(A),Im(B),Re(A)-Re(B)] 
    sub // [Im(A)-Im(B),Re(A)-Re(B)]
    swap1 // [Re(A)-Re(B),Im(A)-Im(B)]

}

/// @notice multiplication
// a * b

#define macro MUL_Z() = takes(4) returns(2){
    //INPUT STACK => [RE(a),RE(b),IM(a),IM(b)]
    dup1 // [Re(A),Re(A),Re(B),Im(A),Im(B)]
    dup5 // [Im(B),Re(A),Re(A),Re(B),Im(A),Im(B)]
    mul // [Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B)]
    dup3 // [Re(B),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B)]
    dup5 // [Im(A),Re(B),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B)]
    mul // [Re(B)*Im(A),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B)]
    add // [Re(A)*Im(B)+Re(B)*Im(A) ,Re(A) ,Re(B) ,Im(A) ,Im(B) ]
    swap4 // [Im(B) , Re(A) ,Re(B) ,Im(A) ,Re(A)*Im(B)+Re(B)*Im(A)]
    swap1 // [Re(A),Im(B),Re(B),Im(A),Re(A)*Im(B)+Re(B)*Im(A)]
    swap3 // [Im(A),Im(B),Re(B),Re(A),Re(A)*Im(B)+Re(B)*Im(A)]
    mul // [Im(A)*Im(B),Re(B),Re(A),Re(A)*Im(B)+Re(B)*Im(A)]
    swap2 // [Re(A),Re(B),Im(A)*Im(B),Re(A)*Im(B)+Re(B)*Im(A)]
    mul // [Re(A)*Re(B),Im(A)*Im(B),Re(A)*Im(B)+Re(B)*Im(A)]
    sub // [Re(A)*Re(B)-Im(A)*Im(B),Re(A)*Im(B)+Re(B)*Im(A)]
    
}

/// @notice division
// a / b

#define macro DIV_Z() = takes(4) returns(2) {
    //INPUT STACK => [RE(a),RE(b),IM(a),IM(b)]
    0x02 // [2,Re(A),Re(B),Im(A),Im(B)]
    dup2 // [Re(B),2,Re(A),Re(B),Im(A),Im(B)]
    exp // [Re(B)**2 ,Re(A),Re(B),Im(A),Im(B)]
    0x02 // [2,Re(B)**2 ,Re(A),Re(B),Im(A),Im(B)]
    dup5 // [Im(B),2,Re(B)**2,Re(A),Re(B),Im(A),Im(B)]
    exp // [Im(B)**2,Re(B)**2,Re(A),Re(B),Im(A),Im(B)]
    add // [Im(B)**2+Re(B)**2,Re(A),Re(B),Im(A),Im(B)] , Let Im(B)**2+Re(B)**2 be X
    swap4 // [Im(B),Re(A),Re(B),Im(A),X]
    swap3 // [Im(A),Re(A),Re(B),Im(B),X]
    swap2 // [Re(B),Re(A),Im(A),Im(B),X]
    swap1 // [Re(A),Re(B),Im(A),Im(B),X]
    dup1 // [Re(A),Re(A),Re(B),Im(A),Im(B),X]
    dup5 // [Im(B),Re(A),Re(A),Re(B),Im(A),Im(B),X]
    mul // [Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B),X]
    dup3 // [Re(B),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B),X]
    dup5 // [Im(A),Re(B),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B),X]
    mul // [Re(B)*Im(A),Re(A)*Im(B),Re(A),Re(B),Im(A),Im(B),X]
    sub // [Re(B)*Im(A)-Re(A)*Im(B),Re(A) ,Re(B) ,Im(A) ,Im(B),X ]
    swap4 // [Im(B) , Re(A) ,Re(B) ,Im(A) ,Re(B)*Im(A)-Re(A)*Im(B),X]
    swap1 // [Re(A),Im(B),Re(B),Im(A),Re(B)*Im(A)-Re(A)*Im(B),X]
    swap3 // [Im(A),Im(B),Re(B),Re(A),Re(B)*Im(A)-Re(A)*Im(B),X]
    mul // [Im(A)*Im(B),Re(B),Re(A),Re(B)*Im(A)-Re(A)*Im(B),X]
    swap2 // [Re(A),Re(B),Im(A)*Im(B),Re(B)*Im(A)-Re(A)*Im(B),X]
    mul // [Re(A)*Re(B),Im(A)*Im(B),Re(B)*Im(A)-Re(A)*Im(B),X]
    add // [Re(A)*Re(B)+Im(A)*Im(B),Re(B)*Im(A)-Re(A)*Im(B),X] ; Let Re(A)*Re(B)+Im(A)*Im(B) be Y and Re(B)*Im(A)-Re(A)*Im(B) be W
    [X3]// [1e18,Y,W,X] 
    mul // [1e18*Y,W,X]
    dup3 // [X,1e18*Y,W,X]
    swap1 // [1e18*Y,X,W,X]
    sdiv // [1e18*Y/X,W,X]
    swap2 // [X,W,1e18*Y/X]
    swap1 // [W,X,1e18*Y/X]
    [X3]// [1e18,W,X,1e18*Y/X]
    mul // [1e18*W,X,1e18*Y/X]
    sdiv // [1e18*W/X,1e18*Y/X]
    swap1 // [1e18*Y/X,1e18*W/X]  

}


/// @notice
// a**2 + b**2 = r**2
// a and b are int
// return r
#define macro CALC_R() = takes(2) returns(1) {
    // INPUT STACK => [a,b] 
    dup1
    mul 
    swap1
    dup1
    mul
    swap1
    SQRT()
}

/// @notice
//cartesian to polar 

#define macro TO_POLAR() = takes(2) returns(2) {
    // INPUT STACK => [RE(a),IM(a)]
    dup2 // [Im(a),Re(a),Im(a)]
    dup2 // [Re(a),Im(a),Re(a),Im(a)]
    CALC_R() // [r,Re(a),Im(a)]
    dup1 // [r,r,Re(a),Im(a)]
    0x00 // [0,r,r,Re(a),Im(a)]
    slt // [0<r,r,Re(a),Im(a)]
    case1
    jumpi
    swap2 //[Im(a),Re(a),r] , r is negative
    P_ATAN2() //[T,r]
    [X4] //[180e18,T,r]
    add // [180e18+T,r]
    swap1 //[r,T+180e18]

    case1: // r is positive

    swap2 //[Im(a),Re(a),r]
    P_ATAN2() //[T,r]
    swap1 //[r,T]

}

/// @notice
// polar to cartesian

#define macro FROM_POLAR() = takes(2) returns(2) {
    //INPUT STACK => [T,r]
    dup1 // [T,T,r]
    0x00 // [0,T,T,r]
    slt // [0<T,T,r]
    case2
    jumpi
    dup2 // [r,T,r]
    dup2 // [T,r,T,r]
    PUT_NEG1() // [-1,T,r,T,r]
    mul // [-1T,r,T,r]
    SIN() // [sin(-T),r,T,r]
    mul // [sin(-T)*r,T,r]
    PUT_NEG1() // [-1,sin(-T)*r,T,r]
    mul // [-sin(-T)*r,T,r]
    [X3] // [1e18,-sin(-T)*r,T,r]
    swap1 // [-sin(-T)*r,1e18,T,r]
    sdiv // [-sin(-T)*r/1e18,T,r]
    swap1 // [T,-sin(-T)*r/1e18,r]
    COS() // [cos(T),-sin(-T)*r/1e18,r]
    swap1 
    swap2 // [r,cos(T),-sin(-T)*r/1e18]
    mul // [r*cos(T),-sin(-T)*r/1e18]
    [X3] // [1e18,r*cos(T),-sin(-T)*r/1e18]
    swap1 // [r*cos(T),1e18,-sin(-T)*r/1e18]]
    sdiv // [r*cos(T),1e18,-sin(-T)*r/1e18]

    case2: //T is positive
    dup2 // [r,T,r]
    dup2 // [T,r,T,r]
    SIN() // [sin(T),r,T,r]
    mul // [sin(T)*r,T,r]
    [X3] // [1e18,sin(T)*r,T,r]
    swap1 // [sin(T)*r,1e18,T,r]
    sdiv // [sin(T)*r/1e18,T,r]
    swap1 // [T,sin(T)*r/1e18,r]
    COS() // [cos(T),sin(T)*r/1e18,r]
    swap1 
    swap2 // [r,cos(T),sin(T)*r/1e18]
    mul // [r*cos(T),sin(T)*r/1e18]
    [X3] // [1e18,r*cos(T),sin(T)*r/1e18]
    swap1 // [r*cos(T),1e18,sin(T)*r/1e18]]
    sdiv // [r*cos(T),1e18,sin(T)*r/1e18]
}

#define macro P_ATAN2() = takes(2) returns(1) {
   // INPUT STACK => [y,x]
   dup1 // [y,y,x]
   swap2 // [x,y,y]
   P_ATAN2_INNER_CALC() // [T,y]
   swap1 // [y,T]
   0x00 // [0,y,T]
   sgt // [0>y,T]
   case3
   jumpi 

   case3:
   PUT_NEG1() // [-1,T]
   mul // [-T] 
   
}

#define macro ATAN1TO1() = takes(1) returns(1){
 // INPUT STACK => [x]
 [X7] // [X7,x]
 dup1 // [x,X7,x]
 mul // [x*X7,x]
 [X3] // [1e18,x*X7,x]
 swap1 // [x*X7,1e18,x]
 sdiv // [x*X7/1e18,x]
 [X6] // [X6,x*X7/1e18,x]
 add // [X6+x*X7/1e18,x]
 [X3] //
 dup3 // [x,1e18,X6+x*X7/1e18,x]
 sub // [x-1e18,X6+x*X7/1e18,x]
 dup3 // [x,x-1e18,X6+x*X7/1e18,x]
 mul // [x*(x-1e18),X6+x*X7/1e18,x]
 [X3] // [1e18,x*(x-1e18),X6+x*X7/1e18,x]
 swap1 // [x*(x-1e18),1e18,X6+x*X7/1e18,x]
 sdiv // [x*(x-1e18)/1e18,X6+x*X7/1e18,x]
 mul // [(x*(x-1e18)/1e18)*(X6+x*X7/1e18),x]
 swap1 // [x,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 [X5] // [X5,x,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 mul // [X5*x,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 [X3] // [1e18,X5*x,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 swap1 // [X5*x,1e18,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 sdiv // [X5*x/1e18,(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 sub // [X5*x/1e18-(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 [X3] // [1e18,X5*x/1e18-(x*(x-1e18)/1e18)*(X6+x*X7/1e18)]
 swap1 // [X5*x/1e18-(x*(x-1e18)/1e18)*(X6+x*X7/1e18),1e18]
 sdiv // [X5*x/1e18-(x*(x-1e18)/1e18)*(X6+x*X7/1e18)/1e18]
}

#define macro LN() = takes(2) returns(1) {
   //INPUT STACK => [Re(A),Im(A)]
   TO_POLAR() // [r,T]
   LOGE_PRB() // [ln(r),T]
}

#define macro SQRT() = takes(2) returns(1){

}

///@notice e^(a+bi) calculation

#define macro EXP_Z() = takes(2) returns(2) {
 //INPUT STACK => [Re(A),Im(A)]
  [e] // [e,Re(A),Im(A)]
  exp // [e**Re(A),Im(A)]
  FROM_POLAR()

}

///@notice power of complex numbers

#define macro POW() = takes(3) returns(2) {
   //INPUT STACK => [Re(a),Im(b),n]
    TO_POLAR() // [r,T,n]
    swap1 // [T,r,n]
    dup3 // [n,T,r,n]
    mul // [n*T,r,n]
    [X3] // [1e18,n*T,r,n]
    swap1 // [n*T,1e18,r,n]
    sdiv // [n*T/1e18,r,n]
    swap2 // [n,r,n*T/1e18]
    swap1 // [r,n,n*T/1e18]
    exp // [r**n,n*T/1e18] 
    swap1 // [n*T/1e18,r**n]
    dup1 // [n*T/1e18,n*T/1e18,r**n] , Let n*T/1e18 = x
    SIN() // [sin(x),x,r**n]
    swap1 // [x,sin(x),r**n]
    COS() // [cos(x),sin(x),r**n]
    dup3 // [r**n,cos(x),sin(x),r**n]
    mul // [r**n*cos(x),sin(x),r**n]
    swap2 
    mul // [r**n*sin(x),r**n*cos(x)]
    [X3] // [1e18,r**n*sin(x),r**n*cos(x)]
    dup1 // [1e18,1e18,r**n*sin(x),r**n*cos(x)]
    swap2 // 
    sdiv // [r**n*sin(x)/1e18 , 1e18 , r**n*cos(x)]
    swap2 
    sdiv  //[r**n*cos(x)/1e18,r**n*sin(x)/1e18]
}



